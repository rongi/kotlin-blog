---
layout: post
title: "Implementing your presenter with Rx or Functional Reactive architecture for Android applications"
excerpt: "Implementing your presenter with Rx or Functional Reactive architecture for Android applications"
tags: rxjava rx mvi frp functional reactive programming
categories: rxjava
---

It is pretty common to implement data layers with Rx: just glue up some requests together with `merge()` or `concat()` and subscribe to the result. It's not so common to implement presentation layers (presenters or view models) with Rx. And that is kind of surprising, because what is a presentation layer? It's something that receives asynchronous signals (user clicks, network responses or system events), processes them, and emits asynchronous signals back (view updates mostly). It's a fundamentally asynchronous system, type of systems Rx was designed for.

Maybe it sounds good in theory, but will it work in real life? The only way to answer this question is to try this approach on a live application with requirements coming from real business needs. I had an opportunity like that a year ago and this article is about what came out of it.

Now, this approach starts to gain traction slowly; if you heard words "MVI" or "MVVM with Rx", it's the same beast. But back then these words weren't googlable yet, so it was a surprise that the thing actually worked. And not just worked, it felt like a long lost true way to implement UI. Traditional imperative approach with stateful presenters or view models started to feel synthetic and overcomplicated; I had a similar feeling while adopting functional programming after years of Android Java.

## Presenter is a function

I started my journey with a good old `class Presenter`; I just tried to implement its guts with Rx. Eventually, it became obvious (and it was an exciting surprise) that the class itself is no longer needed. It looked like presenter is trying to take this form:

```kotlin
fun present(/* input streams (observables) */): ViewModel {   
  // ... 
}
```

This is a function. What does it do? Well, it transforms a bunch of observables into a bunch of observables.

As input it takes a bunch of observables with user interaction events; a click on a button is an example of such an event. It's easy to construct an observable that emits an item each time this event happens. Another example is an observable that emits a string each time user types something in an input field.

```kotlin
fun present(
  updateButtonClicks: Observable<Unit>,
  passwordEditTextChanges: Observable<String>
): ViewModel {   
  // ... 
}
```

An output of this function is an instance of a `ViewModel` object, which is just a container for a bunch of observables with view states. View state is some property of a view, like visibility, margin or button text:

```kotlin
data class ViewModel(   
  val progressViewIsVisible: Observable<Boolean>,
  val updateButtonText: Observable<String>
 )
```

Here are these properties on the screen:

<img src="{{site.url}}{{site.baseurl}}/assets/rxui/view-states.png" alt="Drawing" style="width: 100%;"/>

Activity can subscribe to these view states and map their values to corresponding view properties:

```kotlin
viewModel.progressViewIsVisible.subscribe {
  progressView.visible = it
}

viewModel.updateButtonText.subscribe {
  updateButton.setText(it)
}
```

So, to sum this up, `present()` is a function that transforms streams of clicks and other interaction events into streams of view states:

{:refdef: style="text-align: center;"}
<img src="{{site.url}}{{site.baseurl}}/assets/rxui/clicks-present-viewstates.png" alt="Drawing" style="width: 600px;"/>
{: refdef}

This is how typical activity looks like with this approach:

```kotlin
class MainActivity : Activity() {

  override fun onCreate(savedInstanceState: Bundle?) {
    /* ... */
    val viewModel = present(/* input streams */)
    render(viewModel)
  }

}
```

Yes, it's that simple. Activity's role is just to resolve dependencies for the `present()` function and to provide an entry point to start the whole process.

## Implementing present() function

`present()` function is the heart of the activity. It owns all the complexity and all non-trivial presentation logic. How is this function implemented? Let's see that on an example of this activity:

{:refdef: style="text-align: center;"}
<img src="{{site.url}}{{site.baseurl}}/assets/rxui/list-of-articles.png" alt="Drawing" style="width: 300px;"/>
{: refdef}

It has an "Update" button. Each time we click it, a new list of articles is downloaded from the server and displayed on the screen.

How to implement this? As an input, we can expect to have a stream of button clicks and something that can download articles for us (let's call it `ArticlesProvider`):

```kotlin
fun present( 
  updateButtonClicks: Observable<Unit>, 
  articlesProvider: ArticlesProvider
): ViewModel {
  /* ... */
}
```

We can combine these two inputs into an observable that downloads and emits a list of articles every time update button is clicked:

```kotlin
val articles = updateButtonClicks
  .flatMap { articlesProvider.getArticles() }    
```

Let's suppose activity knows how to "render" these articles (by passing them to a proper `RecyclerView` adapter for example). Then we can consider this observable a view state and final implementation of the `present()` function will look like this:

```kotlin
fun present( 
  updateButtonClicks: Observable<Unit>, 
  articlesProvider: ArticlesProvider
): ViewModel { 
  val articles = updateButtonClicks
    .flatMap { articlesProvider.getArticles() }    

  return ViewModel( 
    articles = articles 
  )
}
```

It's funny how it resembles ordinary presenter, but let's look at the `articles` observable again:

```kotlin
val articles = updateButtonClicks
  .flatMap { articlesProvider.getArticles() }    
```

This expression defines a rule how to compose `articles` view state. To define another view state, just create a new rule and place it, say, bellow the previous one:

```kotlin
fun present( 
  updateButtonClicks: Observable<Unit>, 
  articlesProvider: ArticlesProvider
): ViewModel { 
  val articles = updateButtonClicks
    .flatMap { articlesProvider.getArticles() }    
    .publish().autoConnect() 

  // This is the new view state.
  // It controls visibility of an “empty state” view
  // which is visible when there is no articles to show
  val emptyViewVisibility = just(true)
    .concatWith(articles.map { it.isEmpty() })

  return ViewModel( 
    articles = articles 
    emptyViewVisibility = emptyViewVisibility 
  )
}
```

And this is how the work process looks like. We identify view states we need to implement, and then we just write a rule for each of these view states and place these rules one after another. At the end, `present()` function is just a list of view state definitions. It may contain other stuff, of course, like definitions of observables which are used in construction of several view states, but mostly `present()` function is just a list of view states.

Compared to a traditional presenter, this form feels very... unentangled, and this affects how fast complexity of your solution grows. My general feeling is that with a traditional presenter complexity of your solution increases as a square of a complexity of the requirements. Each added requirement tends to affect several pieces of code, and so, the more code you already have, the more is the complexity increase after each update. With the Rx approach, it feels like updates are usually much more isolated and complexity of the code is more like of linear dependency on a complexity of the requirements. This means that the bigger and more complex your activity is, the greater are the advantages of implementing your presenter with Rx. With simplest activities it feels like complexity of both solutions is nearly the same.

## Why complexity matters

It's not hard to illustrate what this decrease in complexity gives to you as a developer. Imagine you came to your code after a while. Probably it's time to change how one of the view states works or fix a bug in one of them. To change something, you need to understand it first. Now, you'll probably click on a variable or a function responsible for this view state and browse through all the huge presenter to see where the thing is used and how it's modified. You build a mental model in your head. The problem is, this mental model is pretty unstable. If a colleague comes to your desk and asks something, the model is broken and you'll have to build it again. With Rx presenter it's pretty cheap to rebuild the model, all necessary parts are there, in the single place: in the place where view model observable is defined.

Now, imagine how simpler it is to modify this kind of code, how you can see immediately what your changes will affect and what they will not. You can be sure that you are not introducing some weird bug by manipulating some shared state in an unexpected way. Just because all state mutations are restricted to a single place, to the place where corresponding observable is defined. You can grasp everything that happens with a state with a single look.

## The true form of a presenter

In the end, I want to share another exciting thing about this approach. This insight comes from André Staltz's talks and MVI documentation from cycle.js site. Let's look again at our activity:

```kotlin
class MainActivity : Activity() {

  override fun onCreate(savedInstanceState: Bundle?) {
    /* ... */
    val viewModel = present(/* input streams */)
    render(viewModel)
  }

}
```

`onCreate()` function serves a role of a main entry point. It's like a `main()`, but for an activity. Having this in mind, we may notice that the code above resembles this:

```kotlin
fun main() {
  render(preset(userInput()))
}
```

What does it mean? We just took our super complex activity, consisting of a view, presenter, asynchronous events of all kinds, and turned it into a composition of three functions. Each of these functions has a deadly simple meaning. Our program suddenly became so simple and so easy to think about. Maybe this is the natural way of how UI programming should be done?

And look at the presenter. It was an abomination with hard to grasp role and potentially unapprehensive knot of states inside. Now it's a transform function, simple and elegant. It feels like presenter's true form; it was hidden all these years in a pile of OOP boilerplate and Rx with FRP just helped to reveal it.

I'm pretty convinced now that FRP is the natural way to write UI applications. From what I saw so far, it excels traditional imperative approach in all aspects; it feels like programming paradigm of the future.
