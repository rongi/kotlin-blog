---
layout: post
title: "Functional Reactive architecture for Android applications"
excerpt: "Rx UI"
tags: rxjava rx mvi
categories: rxjava
published: false
---

## I was curious

It is pretty common to implement data layers with Rx.

RxJava common for data layer
Is Rx suitable for View logic?

Can you write stateless presenter using only Rx?

I've tried and came to something better

It was a successful experience

## present() function

The idea is to write your presenter as a function that transforms user input into view states:

```kotlin
fun present(/* userInput */): ViewModel {   
  // ... 
}
```

User input comes in the form of observables with interaction events, like clicks or input field changes

```kotlin
fun present(
  updateButtonClicks: Observable<Unit>,
  passwordEditTextChanges: Observable<String>
): ViewModel {   
  // ... 
}
```

View model is also a collection of streams, this times with view states:

```kotlin
data class ViewModel(   
  val activityTitle: Observable<String>,   
  val showProgress: Observable<Boolean>
 )
```

Our `present()` function just transforms a bunch of streams into another bunch of streams. It's a simple transform function. Now, as you'll see further, `present()` function can do anything your conventional OOP presenter can. It does the same thing, but in functional way. Yet it's so simple to describe what this function does. One simple sentence. This fact only tells us that we are on the right way.


## More details

We render view states just by subscribing to the observables and mapping values to the views:
```kotlin
fun render(model: ViewModel) {
  with(model) {
    activityTitle.subscribe { this.setTitle(it) }
    showProgress.subscribe { progressView.visible = it }
  }
}
```

And this is how our `Activity` usually looks like:

```kotlin
class MainActivity : Activity() {

  override fun onCreate(savedInstanceState: Bundle?) {
    /* ... */

    val model = present(/* userInput */)
    render(model)
  }

  fun render(model: ViewModel) {
    with(model) {
      activityTitle.subscribe { this.setTitle(it) }
      showProgress.subscribe { progressView.visible = it }
    }
  }
}
```

## present() function

That's enough about what comes inside `present()` function and what comes out, it's pretty trivial matter. Let's proceed to the cool part, what's inside `presenter()` function. Because this is important thing, this function is the part that matters, it is our real program. The rest is just a periphery.

Let's implement an activity like this:

[Image]

We have an "update" button. When we hit it, a list of articles is downloaded and displayed.

This is how `present()` function for this activity will look like:

```kotlin
fun present( 
  updateButtonClicks: Observable<Unit>, 
  articlesService: ArticlesService 
): ViewModel { 
  val articles = updateButtonClicks
    .flatMap { articlesService.getArticles() }    

  return ViewModel( 
    articles = articles 
  )
}
```

You can notice that it looks very much like your ordinal Presenter. Just class fields become parameters.

## Moar states

What happens if we need to add more states? For example, what if we need to show a text "There is no articles here" when the view is empty? How should we proceed? Should we make our `articles` observable more complex and make it return some composite value instead?

No, just build a new observable using the existing ones as building blocks. Like this:

```kotlin
fun present( 
  updateButtonClicks: Observable<Unit>, 
  articlesService: ArticlesService 
): ViewModel { 
  val articles = updateButtonClicks
    .flatMap { articlesService.getArticles() }    
    .publish().autoConnect() 

  val emptyViewVisibility = just(true)
    .concatWith(articles.map { it.isEmpty() })

  return ViewModel( 
    articles = articles 
    emptyViewVisibility = emptyViewVisibility 
  )
}
```

Note how we just reused `articles` observable to build a new view state. Many articles on this topic misses this trick while using it is the difference between solution to be actually working and not.

## Can implement UI with any level of complexity

## It is a simple and scalable way

## Signals?

## Testing?

## Composition?

## Relation to MVI?

## Drafts

Now look, our `present()` function can do anything OOP presenter can, but it's so simple and elegant, it has one single easily to express responsibility. It's so sinple to reason about this function.

All these OOP architectures hanging around feels like a huge scam or conspiracy to sell more GoF books and Uncle Bob's videos.

Write it like a single function with one simple role: to convert user input into view states. That's all. Sounds crazy? Sounds like it will never work? Well, after I've tried this, doing it in any other way feels like a huge mistake.

It is the same as MVI. MVI variant is just an option.
