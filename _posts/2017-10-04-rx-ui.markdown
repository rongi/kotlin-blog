---
layout: post
title: "Functional Reactive architecture for Android or implementing your presenter with Rx"
excerpt: "Rx UI"
tags: rxjava rx mvi frp functional reactive programming
categories: rxjava
published: false
---

It is pretty common to implement data layers with Rx: just glue up some requests together with `merge()` or `concat()` and subscribe to the result. It's not so common to implement presentation layers (presenters or view models) with Rx. And that is kind of surprising, because what is a presentation layer? It's something that receives asynchronous signals (user clicks, network responses or system events), processes them, and emits asynchronous signals back (view updates mostly). It's a fundamentally asynchronous system, type of systems Rx was designed for.

Okay, so, may be it sounds good in theory, but will it work in real life? I had this question in my head for some time, until an opportunity came to check it in a production application. Needles to say, I was happy to take this opportunity.

Now, this approach starts to gain traction slowly; if you heard words "MVI" or "MVVM with Rx", it's the same beast. But back then, these things wasn't googlable yet, so it was a surprise for me that the thing actually worked. And not just worked, it felt like a long lost true way to implement UI. Traditional imperative approach with stateful presenters or view models started to feel synthetic and overcomplicated; you have the same feeling when start to use some functional patterns instead of their clunky OOP counterparts.

## Presenter is a function

I started my journey with a traditional `class Presenter` (which role is to incorporate all the presentation logic), and just tried to implement it's guts with Rx. But it quickly became obvious, that the class itself is no longer needed. My presenter was trying to take this form:

```kotlin
fun present(/* input streams (observables) */): ViewModel {   
  // ... 
}
```

A function. And function with a very simple meaning: it transforms observables with user interaction events into observables with view states.

[Image: clicks -present()-> view state]

What are the "user interaction events" I'm talking about? Most common example will be an observable that emits an item each time a button is clicked. Another example will be an observable that emits contents of an input field each time user types something in it.

This is how these observables will look in the signature of a `present()` function:

```kotlin
fun present(
  updateButtonClicks: Observable<Unit>,
  passwordEditTextChanges: Observable<String>
): ViewModel {   
  // ... 
}
```

`present()` function then transforms these input streams into a collection of view states, packs them into a `ViewModel` class and returns it. `ViewModel` is just a named collection of observables:

```kotlin
data class ViewModel(   
  val progressViewIsVisible: Observable<Boolean>,
  val updateButtonText: Observable<String>
 )
```

[Image of a screen with observables and corresponding views]

To render, we just subscribe to any of these observables and map their values to view properties:

```kotlin
viewModel.progressViewIsVisible.subscribe {
  progressView.visible = it
}

viewModel.updateButtonText.subscribe {
  updateButton.setText(it)
}
```

This is how whole process looks like in an activity:

```kotlin
class MainActivity : Activity() {

  override fun onCreate(savedInstanceState: Bundle?) {
    /* ... */
    val viewModel = present(/* input streams */)
    render(viewModel)
  }

}
```

Presenter become a function. This change alone is a good thing: it decreases complexity (because functions are simpler than classes and stateless is simpler than stateful) and it improves our ability to reason about the app by providing simple and clear abstraction of the presentation layer as a transform function. Yet most drastic decrease of complexity happens inside `present()` function itself.

## Implementing present() function

`present()` function is the heart of our presentation layer. It owns all the complexity and all non-trivial presentation logic. How is this function implemented? Let's see that on an example of this activity:

[Image]

It has an "Update" button. Each time we click it, a new list of articles is downloaded from the server and displayed on screen.

How to implement this? As an input, we can expect to have a stream of button clicks and some service/data provider that can download articles for us (let's call it `ArticlesProvider`):

```kotlin
fun present( 
  updateButtonClicks: Observable<Unit>, 
  articlesProvider: ArticlesProvider
): ViewModel {
  /* ... */
}
```

We can combine these two inputs into an observable that downloads and emits articles on each button click:

```kotlin
val articles = updateButtonClicks
  .flatMap { articlesProvider.getArticles() }    
```

Let's suppose activity knows how to "render" these articles (by passing them to a `RecyclerView` adapter for example). Then this observable is a view state and final implementation of the `present()` function will look like this:

```kotlin
fun present( 
  updateButtonClicks: Observable<Unit>, 
  articlesProvider: ArticlesProvider
): ViewModel { 
  val articles = updateButtonClicks
    .flatMap { articlesProvider.getArticles() }    

  return ViewModel( 
    articles = articles 
  )
}
```

It's funny how it resembles ordinary presenter, but let's look into the `articles` observable again:

```kotlin
val articles = updateButtonClicks
  .flatMap { articlesProvider.getArticles() }    
```

This expression defines a rule how to compose `articles` view state. If we need to define another view state, just create a new rule and place it bellow the last one. For example, if we need to show "No articles" placeholder, when the view is empty, we can do it like this:

```kotlin
fun present( 
  updateButtonClicks: Observable<Unit>, 
  articlesProvider: ArticlesProvider
): ViewModel { 
  val articles = updateButtonClicks
    .flatMap { articlesProvider.getArticles() }    
    .publish().autoConnect() 

  // New view state
  val emptyViewVisibility = just(true)
    .concatWith(articles.map { it.isEmpty() })

  return ViewModel( 
    articles = articles 
    emptyViewVisibility = emptyViewVisibility 
  )
}
```

And this is how the work process looks like. We identify view states we want to implement and then we write a rule for each of these view states. Rule after a rule, our app is fully implemented. Our application is just a list of rules at the end, and this brings us to the most important benefit of the approach.

## Maintaining complexity

1. It's important to keep code simple, it's the main challenge of the programming now
2. Explain why complexity in traditional approach increases as a square factor

No matter how complex your requirements are, `present()` function will be just a simple list of loosely coupled rules. As your application grows, there will be just more of them. It feels like complexity of your application is the same as complexity of the requirements, while with the traditional stateful approach it feels like complexity is a square of that. The bigger and more complex your activity is, the greater are the advantages of implementing your presenter with Rx.

## Easy to understand and modify

Another advantage, possibly connected to the previous one, is that it's easier to understand the code. Let me explain that on an example. Imagine you came to your code after a while. Probably it's time to change how one of the view states works or fix a bug in one of them. What you need to do now is to understand again the logic behind your view states. How would you do it with traditional OOP presenter? You'll probably click on a variable or a function corresponding to this view state and browse through all the huge presenter to understand how the pieces are connected. You build a mental model in your head. The problem is, this mental model is pretty unstable. If a colleague comes to your desk and asks something, this model will break and you'll have to build it again. With Rx presenter it's pretty cheap to rebuild the model, all necessary parts are there, in the single place: in the place where view model observable is defined.

Now, imagine how simpler it is to modify this kind of code, how you can see immediately what you changes will do and what they will not. You can be sure that you are not introducing some weird bug by manipulating some hidden shared state. Just because you don't mutate any. You just reuse them. State mutations are restricted to a single place, the place where the state is defined.

## The true form of the presenter

Now, I want to share another exciting thing about this approach. Let's look again at our `Activity`:

```kotlin
class MainActivity : Activity() {

  override fun onCreate(savedInstanceState: Bundle?) {
    /* ... */
    val viewModel = present(/* input streams */)
    render(viewModel)
  }

}
```

Having in mind that `onCreate()` is like a `main()` function, but for an activity, we may notice that the code above resembles this:

```kotlin
fun main() {
  render(preset(userInput()))
}
```

What does it mean? We just took our super complex activity, consisting of a view, presenter, asynchronous events of all kinds, and turned it into a composition of three functions, each of them with a deadly simple meaning. Realizing that was a cathartic experience for me, it's like experiencing some beautiful formula or mathematic law for a first time. Our program suddenly became simple and so easy to think about. May be this is the natural way of how UI programming should be done?

And look at the presenter. It was an abomination with a hard to grasp role and now it's a simple transform function. It feels like presenter's true form was hidden all these years in a pile of OOP boilerplate and Rx and FRP just helped to reveal it.

I'm pretty convinced now that FRP and Rx is the natural way to write UI applications. It excels traditional imperative approach in all aspects. It's a programming paradigm of the future.

## Some nuances

## Signals?

Not everything produced by OOP presenter is a view state. How would you start another activity with your functional presenter?

## Testing?

## Composition?

## Relation to MVI?

## Drafts

It's perfectly fine to utilize already constructed observables in the process.

You can notice that this looks very similar to a traditional Presenter. The difference is that variables that used to be class fields are functional parameters now.

The fact that it solves main challenge of ui programming - maintaining complexity - so elegantly and the that it feels so natural tells me that this is a programming paradigm of the future.

It was a truly exciting journey full of insights.

it produces so simple, easy to understand and reason about code, that

The chains themselves can grow pretty complex, but this complexity will just mirror complexity of the requirements.

You can't build application simpler than it's requirements.

I'm pretty convinced now that FRP an Rx is the natural way to write UI applications. It is better than traditional imperative approach in all ways.

It's a programming of the future.

I came to understanding what presenter really is. It just a function that converts a set of data streams into another set of data streams.

Now look, our `present()` function can do anything OOP presenter can, but it's so simple and elegant, it has one single easily to express responsibility. It's so simple to reason about this function.

All these OOP architectures hanging around feels like a huge scam or conspiracy to sell more GoF books and Uncle Bob's videos.

Write it like a single function with one simple role: to convert user input into view states. That's all. Sounds crazy? Sounds like it will never work? Well, after I've tried this, doing it in any other way feels like a huge mistake.

It is the same as MVI. MVI variant is just an option.

It was a successful experience in production environment in with real requirements.

Stateless code

It is an understanding of what presenter is. It became pretty clear to me, that presenter is just something that transforms one set of data streams, mostly user input, like button clicks, into another set of data streams: mostly view states.

It's just a simple transform function. It plays exactly the same role traditional OOP presenters do. And it can do anything OOP presenter can do. This is a functional form of the presenter became possible by the power of Rx. This form releases power of Functional Programming applied to UI programming.

Yet it's so simple to describe what this function does. One simple sentence. This fact only tells us that we are on the right way.

If you know FRP as good as imperative programming, then this approach is as good as imperative programming on simple views and quickly gains value when complexity goes up.

It was exciting journey full of insights,

<!-- And I knew by this time that RxJava is super suitable for building data layers and it was a widely accepted practice in Android community to use it for data layers, but at that moment I had a question in my mind "Is it suitable for building UI logic also It should be only reasonable that it is suitable, because UI logic is exactly the thing RxJava was created to handle a bunch of asynchronous signals transformed to another bunch of signals. So I tried to implement some UI logic and it turned out that it just worked, and not only worked, but resulting code was much more clean, easy to understand and maintain than traditional imperative code So, today I want to show you how this solution looked like. And probably get you as excited as I'm about it. -->
