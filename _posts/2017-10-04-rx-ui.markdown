---
layout: post
title: "Functional Reactive architecture for Android or implementing your presenter with Rx"
excerpt: "Rx UI"
tags: rxjava rx mvi frp functional reactive programming
categories: rxjava
published: false
---

It is pretty common to implement data layers with Rx: just glue up some requests together with `merge()` or `concat()` and subscribe to the result. But it's not so common to implement presentation layers (presenters or view models) with Rx. Yet presentation layers is exactly type of systems Rx is designed for: it's a complex fundamentally asynchronous system. But even if it's suitable in theory, will it work in real life? Will it survive pressure of real life requirements? I had this question in my head for some time, so when an opportunity to check it arise, I've tried.

Now, this approach starts to gain traction slowly; if you heard about MVI or MVVM with Rx, it's the same beast. But back then it wasn't really googlable, so it was a surprise for me that the thing actually worked. And not only worked, it felt like a long lost true way to implement UI. Traditional imperative approach with stateful presenters or view models started to feel like some overcomplicated synthetic abomination --- you have the same feeling when start to use some functional patterns instead of their clunky OOP counterparts.

While the approach itself is very simple, a few implementation details should be shared in order to understand how exactly it works.

## Presenter is a function

I'd started my journey with a traditional `class Presenter`, and just tried to implement logic inside with Rx, step by step. It quickly became obvious though, that class is no longer needed, it became obvious that my presenter is trying to take this form:

```kotlin
fun present(/* input streams, dependancies */): ViewModel {   
  // ... 
}
```

A class became a function. The meaning of this function is very simple. It transforms various dependancies plus system events and user interaction events into view states.

[Image: clicks -present()-> view state]

As an input it takes a collection of user interaction events, like button clicks or text field changes:

```kotlin
fun present(
  updateButtonClicks: Observable<Unit>,
  passwordEditTextChanges: Observable<String>
): ViewModel {   
  // ... 
}
```

It transforms them into a collection of view states: text field values, view visibility flags, etc.:

```kotlin
data class ViewModel(   
  val updateButtonText: Observable<String>,   
  val progressVisibility: Observable<Boolean>
 )
```

Presenter became a simple transform function. It transforms observables with user input into observables with view states.

As you'll see further, this function can do anything traditional OOP presenter can. It does the same thing, fulfills the same role, but in a functional way.

## View model

Again, this is how view model looks like:

```kotlin
data class ViewModel(   
  val updateButtonText: Observable<String>,   
  val progressVisibility: Observable<Boolean>
 )
```

It's just a collection of observables. To render one of those, we just subscribe and map it's values to the view:

```kotlin
viewModel.progressVisibility.subscribe {
  progressView.visible = it
}
```

Ans this is how activity usually looks like:

```kotlin
class MainActivity : Activity() {

  override fun onCreate(savedInstanceState: Bundle?) {
    /* ... */
    val viewModel = present(/* userInput */)
    render(viewModel)
  }

}
```

The `render()` function just goes through each of the view models and renders them:

```kotlin
fun render(viewModel: ViewModel) {
  with(viewModel) {
    updateButtonText.subscribe { updateButton.setText(it) }
    progressVisibility.subscribe { progressView.visible = it }
  }
}
```

## Implementing present() function

`present()` function is the heart of the presentation layer. It owns all the complexity and all non-trivial presentation logic. How is this function implemented? Let's see that on an example of this activity:

[Image]

It has an "Update" button. Each time we click it, a new list of articles is downloaded from the server and displayed on the screen.

This is how implementation will look like:

```kotlin
fun present( 
  updateButtonClicks: Observable<Unit>, 
  articlesService: ArticlesService 
): ViewModel { 
  val articles = updateButtonClicks
    .flatMap { articlesService.getArticles() }    

  return ViewModel( 
    articles = articles 
  )
}
```

You can notice how this resembles ordinary presenter, but the most interesting part here is this:

```kotlin
val articles = updateButtonClicks
  .flatMap { articlesService.getArticles() }    
```

This expression defines a rule how to transform `updateButtonClicks` observable into `articles` view state while using `articlesService` as a dependancy.

And this is how the work process looks like. We define a rule after a rule. We identify which view state we want to implement next and then we write a rule how to combine user input and other dependencies to get this new view state. It's perfectly fine to utilize already constructed observables in the process.

For example, if we need to show a text "There is no articles here", when the view is empty, we will do it like this:

```kotlin
fun present( 
  updateButtonClicks: Observable<Unit>, 
  articlesService: ArticlesService 
): ViewModel { 
  val articles = updateButtonClicks
    .flatMap { articlesService.getArticles() }    
    .publish().autoConnect() 

  // New observable
  val emptyViewVisibility = just(true)
    .concatWith(articles.map { it.isEmpty() })

  return ViewModel( 
    articles = articles 
    emptyViewVisibility = emptyViewVisibility 
  )
}
```

Now we have two rules. Rule after the rule, and our app is fully implemented.

## It is a simple and scalable way

Well, this looks peculiar you might say, but why ever a decent human being would do that?

Now look again at the previous code example. Notice how simple and easy to understand that piece of code is. It's just a set of rules how to build view states, rule by rule. But surely this will quickly become a mess once a real-life requirements kick in, right? No. No matter how complex are your requirements, `present()` function will still be as simple as that. It will just get more view states and intermediate states inside. This is the incredible power of the approach: complexity of your application is the same as complexity of the requirements. With traditional stateful approaches it feels like the complexity is square of that. This means that the bigger and more complex your activity is, the greater are the advantages of functional approach.

## Easy to understand and reason about

Now, imagine you came to your code after a while. Probably it's time to change how one of the view states works or fix a bug in one of them. What you need to do now is to understand again the logic behind your view states. How would you do it with traditional OOP presenter? You'll probably click on a variable or a function corresponding to this view state and browse through all the huge presenter to understand how pieces are connected. You build a mental model in your head. You need this mental model to understand how the thing works and change it. Now, this mental model is pretty unstable. If a colleague comes to your desk and asks something it will break and you have to build it again.

How do you do this with functional presenter? You just look at the corresponding variable. That's all. It's all there, all logic behind this view state is there in one place. For you to build the model you just need to look at this piece of the code. And you can be absolutely sure that you missed nothing, that there is no hidden logic or non-obvious state manipulation. The code tells itself how it works in a 100% transparent way.

Now, imagine how simpler it is to modify this kind of code, how you can see immediately what you change will do and most importantly what it will not do. That it will not introduce some weird bug by manipulating some shared state in a way unexpected by some other users of the state.

## The true form of the presenter

If you take another look at the `Activity` implementation, you may notice that our program actually looks like something like this:

```kotlin
fun main() {
  render(preset(userInput()))
}
```

We took our super complex application, consisting of view, presenter, asynchronous events of all kinds, and turned it into a composition of three functions. Each of them have deadly simple meaning. This is just stunning! Our program suddenly became simple and so easy to think about. It's feels like this is the natural way of how UI programming should be done.

And look at the presenter. It was an abomination with a vague role of "updating the view". Now it's a simple function. It feels like it's true form was hidden all this years in OOP husks and it is slowly unveiling now with the power of Rx and FRP.

I'm pretty convinced now that FRP an Rx is the natural way to write UI applications. It is excels traditional imperative approach in all aspects.

It's a programming of the future.

## Signals?

Not everything produced by OOP presenter is a view state. How would you start another activity with your functional presenter?

## Testing?

## Composition?

## Relation to MVI?

## Drafts

You can notice that this looks very similar to a traditional Presenter. The difference is that variables that used to be class fields are functional parameters now.

The fact that it solves main challenge of ui programming - maintaining complexity - so elegantly and the that it feels so natural tells me that this is a programming paradigm of the future.

It was a truly exciting journey full of insights.

it produces so simple, easy to understand and reason about code, that

The chains themselves can grow pretty complex, but this complexity will just mirror complexity of the requirements.

You can't build application simpler than it's requirements.

I'm pretty convinced now that FRP an Rx is the natural way to write UI applications. It is better than traditional imperative approach in all ways.

It's a programming of the future.

I came to understanding what presenter really is. It just a function that converts a set of data streams into another set of data streams.

Now look, our `present()` function can do anything OOP presenter can, but it's so simple and elegant, it has one single easily to express responsibility. It's so simple to reason about this function.

All these OOP architectures hanging around feels like a huge scam or conspiracy to sell more GoF books and Uncle Bob's videos.

Write it like a single function with one simple role: to convert user input into view states. That's all. Sounds crazy? Sounds like it will never work? Well, after I've tried this, doing it in any other way feels like a huge mistake.

It is the same as MVI. MVI variant is just an option.

It was a successful experience in production environment in with real requirements.

Stateless code

It is an understanding of what presenter is. It became pretty clear to me, that presenter is just something that transforms one set of data streams, mostly user input, like button clicks, into another set of data streams: mostly view states.

It's just a simple transform function. It plays exactly the same role traditional OOP presenters do. And it can do anything OOP presenter can do. This is a functional form of the presenter became possible by the power of Rx. This form releases power of Functional Programming applied to UI programming.

Yet it's so simple to describe what this function does. One simple sentence. This fact only tells us that we are on the right way.

If you know FRP as good as imperative programming, then this approach is as good as imperative programming on simple views and quickly gains value when complexity goes up.

It was exciting journey full of insights,

<!-- And I knew by this time that RxJava is super suitable for building data layers and it was a widely accepted practice in Android community to use it for data layers, but at that moment I had a question in my mind "Is it suitable for building UI logic also It should be only reasonable that it is suitable, because UI logic is exactly the thing RxJava was created to handle a bunch of asynchronous signals transformed to another bunch of signals. So I tried to implement some UI logic and it turned out that it just worked, and not only worked, but resulting code was much more clean, easy to understand and maintain than traditional imperative code So, today I want to show you how this solution looked like. And probably get you as excited as I'm about it. -->
