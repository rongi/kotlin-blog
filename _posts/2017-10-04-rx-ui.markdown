---
layout: post
title: "Functional Reactive architecture for Android or how to build your presenter with Rx"
excerpt: "Rx UI"
tags: rxjava rx mvi frp functional reactive programming
categories: rxjava
published: false
---

It is pretty common to implement data layers with Rx: just glue up some requests together with `zip()` or `concatMap()` and subscribe to the result in the presenter. But is it possible to implement presenter itself with Rx? Rx was designed to handle tasks exactly like that --- programming fundamentally asynchronous systems, so at least in theory idea sounds right. But of course you need to try the idea to see if it'll actually work. And it's better to do it in a production application, it is the only way to tell if the idea will survive countless edge cases and pressure of real-life requirements.

So, about a year ago I got this opportunity to try it in a real-life production project. I started by implementing just a little bit of the presenter with Rx. It quickly became obvious though that the approach is so powerful that it's benefits out weight even the necessity to learn completely new programming paradigm. I'd ended up implementing whole UI layer of the app with Rx. The architecture evolved in the process, and here I want to share how it looks like in it's final form.

## Presenter is a function

I started with a traditional presenter and just tried to implement it's content with Rx. But it quickly became clear that a lot of ceremony that comes with traditional OOP presenters is no longer needed. I was quite surprised when it finally became obvious that my presenter is trying to take this form:

```kotlin
fun present(/* userInput */): ViewModel {   
  // ... 
}
```

Yes, it's just a function. And this function has a simple meaning: it transforms one set of observables into another one.

As an input it takes a collection of user interaction events, like button clicks or text field changes:

```kotlin
fun present(
  updateButtonClicks: Observable<Unit>,
  passwordEditTextChanges: Observable<String>
): ViewModel {   
  // ... 
}
```

It transforms them into a collection of view states: text field values, view visibility flags, etc.:

```kotlin
data class ViewModel(   
  val updateButtonText: Observable<String>,   
  val progressVisibility: Observable<Boolean>
 )
```

Presenter became a simple transform function. It transforms observables with user input into observables with view states.

[Image: clicks -present()-> view state]

As you'll see further, this function can do anything traditional OOP presenter can. It does the same thing, fulfills the same role, but in a functional way.

## View model

Again, this is how view model looks like:

```kotlin
data class ViewModel(   
  val updateButtonText: Observable<String>,   
  val progressVisibility: Observable<Boolean>
 )
```

It's just a collection of observables. To render one of those, we just subscribe and map it's values to the view:

```kotlin
viewModel.progressVisibility.subscribe {
  progressView.visible = it
}
```

Ans this is how activity usually looks like:

```kotlin
class MainActivity : Activity() {

  override fun onCreate(savedInstanceState: Bundle?) {
    /* ... */
    val viewModel = present(/* userInput */)
    render(viewModel)
  }

}
```

The `render()` function just goes through each of the view models and renders them:

```kotlin
fun render(viewModel: ViewModel) {
  with(viewModel) {
    updateButtonText.subscribe { updateButton.setText(it) }
    progressVisibility.subscribe { progressView.visible = it }
  }
}
```

## Implementing present() function

So, presenter became a simple transform function. It transforms observables with user input into observables with view states. As you'll see further, this function can do anything traditional OOP presenter can. It does the same thing, fulfills the same role, but in a functional way.

This function is the heart of the presentation layer. It owns all the complexity and all non-trivial presentation logic. How is this function implemented? Let's see that on an example of this activity:

[Image]

It has an "Update" button. Each time we click it, a new list of articles is downloaded from the server and displayed on the screen.

This is how implementation will look like:

```kotlin
fun present( 
  updateButtonClicks: Observable<Unit>, 
  articlesService: ArticlesService 
): ViewModel { 
  val articles = updateButtonClicks
    .flatMap { articlesService.getArticles() }    

  return ViewModel( 
    articles = articles 
  )
}
```

The most interesting part here is this:

```kotlin
val articles = updateButtonClicks
  .flatMap { articlesService.getArticles() }    
```

It's a definition of a rule how to transform `updateButtonClicks` observable into `articles` observable while using `articlesService` as a dependancy.

## More states

What happens if we need to add more states? For example, what if we need to show a text "There is no articles here" when the view is empty? Obviously, we need to add a new view state, but how exactly should we do that? Should we make our `articles` observable more complex and make it return some composite value instead?

No, just build a new observable, new rule. Feel free to use existing ones as building blocks. Like this:

```kotlin
fun present( 
  updateButtonClicks: Observable<Unit>, 
  articlesService: ArticlesService 
): ViewModel { 
  val articles = updateButtonClicks
    .flatMap { articlesService.getArticles() }    
    .publish().autoConnect() 

  // New observable
  val emptyViewVisibility = just(true)
    .concatWith(articles.map { it.isEmpty() })

  return ViewModel( 
    articles = articles 
    emptyViewVisibility = emptyViewVisibility 
  )
}
```

Now we have two rules. And this is how working process looks like in this approach. We identify which view state we want to implement next and then we write a rule how to combine user input and other dependencies to get this new view state. It's perfectly fine to utilize already constructed observables in the process. Rule after the rule, and our app is fully implemented!

## It is a simple and scalable way

Well, this looks peculiar you might say, but why ever a decent human being would do that?

Now look again at the previous code example. Notice how simple and easy to understand that piece of code is. It's just a set of rules how to build view states, rule by rule. But surely this will quickly become a mess once a real-life requirements kick in, right? No! No matter how complex are your requirements, `present()` function will still be as simple as that. It will just get more view states and intermediate states inside. This is the incredible power of the approach: complexity of your application is the same as complexity of the requirements. With traditional stateful approaches it feels like the complexity is square of that. This means that the bigger and more complex your activity is, the greater are the advantages of functional approach.

## Easy to understand and reason about

Now, imagine you came to your code after a while. Probably it's time to change how one of the view states works or fix a bug in one of them. What you need to do now is to understand again the logic behind your view states. How would you do it with traditional OOP presenter? You'll probably click on a variable or a function corresponding to this view state and browse through all the huge presenter to understand how pieces are connected. You build a mental model in your head. You need this mental model to understand how the thing works and change it. Now, this mental model is pretty unstable. If a colleague comes to your desk and asks something it will break and you have to build it again.

How do you do this with functional presenter? You just look at the corresponding variable. That's all. It's all there, all logic behind this view state is there in one place. For you to build the model you just need to look at this piece of the code. And you can be absolutely sure that you missed nothing, that there is no hidden logic or non-obvious state manipulation. The code tells itself how it works in a 100% transparent way.

Now, imagine how simpler it is to modify this kind of code, how you can see immediately what you change will do and most importantly what it will not do. That it will not introduce some weird bug by manipulating some shared state in a way unexpected by some other users of the state.

## The true form of the presenter

If you take another look at the `Activity` implementation, you may notice that our program actually looks like something like this:

```kotlin
fun main() {
  render(preset(userInput()))
}
```

We took our super complex application, consisting of view, presenter, asynchronous events of all kinds, and turned it into a composition of three functions. Each of them have deadly simple meaning. This is just stunning! Our program suddenly became simple and so easy to think about. It's feels like this is the natural way of how UI programming should be done.

And look at the presenter. It was an abomination with a vague role of "updating the view". Now it's a simple function. It feels like it's true form was hidden all this years in OOP husks and it is slowly unveiling now with the power of Rx and FRP.

I'm pretty convinced now that FRP an Rx is the natural way to write UI applications. It is excels traditional imperative approach in all aspects.

It's a programming of the future.

## Signals?

Not everything produced by OOP presenter is a view state. How would you start another activity with your functional presenter?

## Testing?

## Composition?

## Relation to MVI?

## Drafts

You can notice that this looks very similar to a traditional Presenter. The difference is that variables that used to be class fields are functional parameters now.

The fact that it solves main challenge of ui programming - maintaining complexity - so elegantly and the that it feels so natural tells me that this is a programming paradigm of the future.

It was a truly exciting journey full of insights.

it produces so simple, easy to understand and reason about code, that

The chains themselves can grow pretty complex, but this complexity will just mirror complexity of the requirements.

You can't build application simpler than it's requirements.

I'm pretty convinced now that FRP an Rx is the natural way to write UI applications. It is better than traditional imperative approach in all ways.

It's a programming of the future.

I came to understanding what presenter really is. It just a function that converts a set of data streams into another set of data streams.

Now look, our `present()` function can do anything OOP presenter can, but it's so simple and elegant, it has one single easily to express responsibility. It's so simple to reason about this function.

All these OOP architectures hanging around feels like a huge scam or conspiracy to sell more GoF books and Uncle Bob's videos.

Write it like a single function with one simple role: to convert user input into view states. That's all. Sounds crazy? Sounds like it will never work? Well, after I've tried this, doing it in any other way feels like a huge mistake.

It is the same as MVI. MVI variant is just an option.

It was a successful experience in production environment in with real requirements.

Stateless code

It is an understanding of what presenter is. It became pretty clear to me, that presenter is just something that transforms one set of data streams, mostly user input, like button clicks, into another set of data streams: mostly view states.

It's just a simple transform function. It plays exactly the same role traditional OOP presenters do. And it can do anything OOP presenter can do. This is a functional form of the presenter became possible by the power of Rx. This form releases power of Functional Programming applied to UI programming.

Yet it's so simple to describe what this function does. One simple sentence. This fact only tells us that we are on the right way.

If you know FRP as good as imperative programming, then this approach is as good as imperative programming on simple views and quickly gains value when complexity goes up.

It was exciting journey full of insights,

<!-- And I knew by this time that RxJava is super suitable for building data layers and it was a widely accepted practice in Android community to use it for data layers, but at that moment I had a question in my mind "Is it suitable for building UI logic also It should be only reasonable that it is suitable, because UI logic is exactly the thing RxJava was created to handle a bunch of asynchronous signals transformed to another bunch of signals. So I tried to implement some UI logic and it turned out that it just worked, and not only worked, but resulting code was much more clean, easy to understand and maintain than traditional imperative code So, today I want to show you how this solution looked like. And probably get you as excited as I'm about it. -->
