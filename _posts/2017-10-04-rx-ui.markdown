---
layout: post
title: "Functional Reactive architecture for Android or implementing your presenter with Rx"
excerpt: "Rx UI"
tags: rxjava rx mvi frp functional reactive programming
categories: rxjava
published: false
---

It is pretty common to implement data layers with Rx: just glue up some requests together with `merge()` or `concat()` and subscribe to the result. It's not so common to implement presentation layers (presenters or view models) with Rx. And this kind of surprising, because what is a presentation layer? It's something that receives asynchronous signals (user clicks, network responses or system events), processes them, and emits asynchronous signals back (those are view updates mostly). It's a fundamentally asynchronous system, type of systems Rx was designed for.

Okay, so, may be it sounds good in theory, but will it work in real life? I had this question (I was curious) in my head for some time, so when an opportunity arise to check it in a real production application, I was happy to took this opportunity.

This approach starts to gain traction slowly; if you heard words "MVI" or "MVVM with Rx", it's the same beast. But back then, these things wasn't googlable yet, so it was a surprise for me that the thing actually worked. And not just worked, it felt like a long lost true way to implement UI. Traditional imperative approach with stateful presenters or view models started to feel synthetic and overcomplicated; you have the same feeling when start to use some functional patterns instead of their clunky OOP counterparts.

## Presenter is a function

I started my journey with a traditional `class Presenter` (which role is to incorporate all the presentation logic), and just tried to implement it's insides with Rx. It quickly became obvious though, that the class itself is no longer needed, and my presenter is trying to take this form:

```kotlin
fun present(/* input streams */): ViewModel {   
  // ... 
}
```

A class became a function, and this function has very simple meaning: it transforms a set of observables into another set of observables: a set of input streams into a set of view states.

[Image: clicks -present()-> view state]

What are the "input streams" I'm talking about? Here is an example. All clicks on a button can be presented as an observable: this observable emits an item each time user clicks the button. This is the most common example of an "input stream". Another example will be an observable with all updates of a given text field.

And this is how "input streams" will look like in the signature of a `present()` function:

```kotlin
fun present(
  updateButtonClicks: Observable<Unit>,
  passwordEditTextChanges: Observable<String>
): ViewModel {   
  // ... 
}
```

These input streams are transformed into a collection of view states: text field values, view visibilities, etc., packed into a `ViewModel` class:

```kotlin
data class ViewModel(   
  val progressViewIsVisible: Observable<Boolean>,
  val updateButtonText: Observable<String>
 )
```

[Image of a screen with observables and corresponding views]

Which is just a named collection of observables. To render, just subscribe to any of these observables and map their values to view properties:

```kotlin
viewModel.progressViewIsVisible.subscribe {
  progressView.visible = it
}

viewModel.updateButtonText.subscribe {
  updateButton.setText(it)
}
```

And this is how activity usually looks like:

```kotlin
class MainActivity : Activity() {

  override fun onCreate(savedInstanceState: Bundle?) {
    /* ... */
    val viewModel = present(/* input streams */)
    render(viewModel)
  }

}
```

So, presenter become a simple transform function. This change alone decreases complexity of our app (because functions are simpler than classes and stateless is simpler than stateful). It also improves our ability to reason about the app by providing incredibly simple abstraction of a presentation layer. But the most drastic decrease of complexity happens inside `present()` function itself.

## Implementing present() function

`present()` function is the heart of the presentation layer. It owns all the complexity and all non-trivial presentation logic. How is this function implemented? Let's see that on an example of this activity:

[Image]

It has "Update" button. Each time we click it, a new list of articles is downloaded from the server and displayed on the screen.

How to implement this? We can expect to have a stream of button clicks and some mean to download articles as `present()` function parameters:

```kotlin
fun present( 
  updateButtonClicks: Observable<Unit>, 
  articlesService: ArticlesService 
): ViewModel {
  /* ... */
}
```

We can use these two inputs to compose an observable of downloaded articles:

```kotlin
val articles = updateButtonClicks
  .flatMap { articlesService.getArticles() }    
```

And this is how final implementation will look like:

```kotlin
fun present( 
  updateButtonClicks: Observable<Unit>, 
  articlesService: ArticlesService 
): ViewModel { 
  val articles = updateButtonClicks
    .flatMap { articlesService.getArticles() }    

  return ViewModel( 
    articles = articles 
  )
}
```

You can notice how this resembles ordinary presenter, but the most interesting part here is this:

```kotlin
val articles = updateButtonClicks
  .flatMap { articlesService.getArticles() }    
```

This expression defines a rule how to transform input stream `updateButtonClicks` into `articles` view state while using `articlesService` as a dependancy.

What if we need another view state? For example, what if we need to show a text "There is no articles here", when the view is empty? The implementation will look like this:

```kotlin
fun present( 
  updateButtonClicks: Observable<Unit>, 
  articlesService: ArticlesService 
): ViewModel { 
  val articles = updateButtonClicks
    .flatMap { articlesService.getArticles() }    
    .publish().autoConnect() 

  // New observable
  val emptyViewVisibility = just(true)
    .concatWith(articles.map { it.isEmpty() })

  return ViewModel( 
    articles = articles 
    emptyViewVisibility = emptyViewVisibility 
  )
}
```

We've added another rule, another observable, another view state. And this is how work process looks like. We identify which view state we want to implement next and then we write a rule how to combine user input and other dependencies to get this new view state. It's perfectly fine to utilize already constructed observables in the process. Rule after a rule, our app is fully implemented.

(Merge with next chapter)

## Easy to understand and reason about

Now, imagine you came to your code after a while. Probably it's time to change how one of the view states works or fix a bug in one of them. What you need to do now is to understand again the logic behind your view states. How would you do it with traditional OOP presenter? You'll probably click on a variable or a function corresponding to this view state and browse through all the huge presenter to understand how pieces are connected. You build a mental model in your head. You need this mental model to understand how the thing works and change it. Now, this mental model is pretty unstable. If a colleague comes to your desk and asks something it will break and you have to build it again.

How do you do this with functional presenter? You just look at the corresponding variable. That's all. It's all there, all logic behind this view state is there in one place. For you to build the mental model you just need to look at this piece of the code. And you can be absolutely sure that you missed nothing, that there is no hidden logic or non-obvious state manipulation. The code tells itself how it works in a 100% transparent way.

Now, imagine how simpler it is to modify this kind of code, how you can see immediately what you change will do and, most importantly, what it will not do. That it will not introduce some weird bug by manipulating some shared state in a way unexpected by some other users of the state.

## It is a simple and scalable way

Well, this looks peculiar you might say, but why ever a decent human being would do that?

Now look again at the previous code example. Notice how simple and easy to understand that piece of code is. It's just a set of rules how to build view states, rule by rule. But surely this will quickly become a mess once a real-life requirements kick in, right? No. No matter how complex are your requirements, `present()` function will still be as simple as that. It will just get more view states and intermediate states inside. This is the incredible power of the approach: complexity of your application is the same as complexity of the requirements. With traditional stateful approaches it feels like the complexity is square of that. This means that the bigger and more complex your activity is, the greater are the advantages of functional approach.

## The true form of the presenter

If you take another look at the `Activity` implementation, you may notice that our program actually looks like something like this:

```kotlin
fun main() {
  render(preset(userInput()))
}
```

We took our super complex application, consisting of view, presenter, asynchronous events of all kinds, and turned it into a composition of three functions. Each of them have deadly simple meaning. This is just stunning! Our program suddenly became simple and so easy to think about. It's feels like this is the natural way of how UI programming should be done.

And look at the presenter. It was an abomination with a vague role of "updating the view". Now it's a simple function. It feels like it's true form was hidden all this years in OOP husks and it is slowly unveiling now with the power of Rx and FRP.

I'm pretty convinced now that FRP an Rx is the natural way to write UI applications. It is excels traditional imperative approach in all aspects.

It's a programming paradigm of the future.

## Some nuances

## Signals?

Not everything produced by OOP presenter is a view state. How would you start another activity with your functional presenter?

## Testing?

## Composition?

## Relation to MVI?

## Drafts

You can notice that this looks very similar to a traditional Presenter. The difference is that variables that used to be class fields are functional parameters now.

The fact that it solves main challenge of ui programming - maintaining complexity - so elegantly and the that it feels so natural tells me that this is a programming paradigm of the future.

It was a truly exciting journey full of insights.

it produces so simple, easy to understand and reason about code, that

The chains themselves can grow pretty complex, but this complexity will just mirror complexity of the requirements.

You can't build application simpler than it's requirements.

I'm pretty convinced now that FRP an Rx is the natural way to write UI applications. It is better than traditional imperative approach in all ways.

It's a programming of the future.

I came to understanding what presenter really is. It just a function that converts a set of data streams into another set of data streams.

Now look, our `present()` function can do anything OOP presenter can, but it's so simple and elegant, it has one single easily to express responsibility. It's so simple to reason about this function.

All these OOP architectures hanging around feels like a huge scam or conspiracy to sell more GoF books and Uncle Bob's videos.

Write it like a single function with one simple role: to convert user input into view states. That's all. Sounds crazy? Sounds like it will never work? Well, after I've tried this, doing it in any other way feels like a huge mistake.

It is the same as MVI. MVI variant is just an option.

It was a successful experience in production environment in with real requirements.

Stateless code

It is an understanding of what presenter is. It became pretty clear to me, that presenter is just something that transforms one set of data streams, mostly user input, like button clicks, into another set of data streams: mostly view states.

It's just a simple transform function. It plays exactly the same role traditional OOP presenters do. And it can do anything OOP presenter can do. This is a functional form of the presenter became possible by the power of Rx. This form releases power of Functional Programming applied to UI programming.

Yet it's so simple to describe what this function does. One simple sentence. This fact only tells us that we are on the right way.

If you know FRP as good as imperative programming, then this approach is as good as imperative programming on simple views and quickly gains value when complexity goes up.

It was exciting journey full of insights,

<!-- And I knew by this time that RxJava is super suitable for building data layers and it was a widely accepted practice in Android community to use it for data layers, but at that moment I had a question in my mind "Is it suitable for building UI logic also It should be only reasonable that it is suitable, because UI logic is exactly the thing RxJava was created to handle a bunch of asynchronous signals transformed to another bunch of signals. So I tried to implement some UI logic and it turned out that it just worked, and not only worked, but resulting code was much more clean, easy to understand and maintain than traditional imperative code So, today I want to show you how this solution looked like. And probably get you as excited as I'm about it. -->
