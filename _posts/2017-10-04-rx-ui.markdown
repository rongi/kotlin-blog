---
layout: post
title: "Implementing your presenter with Rx or Functional Reactive architecture for Android"
excerpt: "Rx UI"
tags: rxjava rx mvi frp functional reactive programming
categories: rxjava
published: false
---

It is pretty common to implement data layers with Rx: just glue up some requests together with `merge()` or `concat()` and subscribe to the result. It's not so common to implement presentation layers (presenters or view models) with Rx. And that is kind of surprising, because what is a presentation layer? It's something that receives asynchronous signals (user clicks, network responses or system events), processes them, and emits asynchronous signals back (view updates mostly). It's a fundamentally asynchronous system, type of systems Rx was designed for.

May be it sounds good in theory, but will it work in real life? The only way to answer this question is to try this approach on an live application with requirements coming from real business needs. As you may guess, I was lucky to have this opportunity.

Now, this approach starts to gain traction slowly; if you heard words "MVI" or "MVVM with Rx", it's the same beast. But back then, then these words wasn't googlable yet, it was a surprise for me that the thing actually worked. And not just worked, it felt like a long lost true way to implement UI. Traditional imperative approach with stateful presenters or view models started to feel synthetic and overcomplicated; I have had similar feeling while adopting functional programming after years of fasting on Android Java.

## Presenter is a function

I started my journey with a traditional `class Presenter`, which, as you know, incorporates all the presentation logic, and just tried to implement it's guts with Rx. It was a surprise when it became obvious, that the class itself is no longer needed. It looked like presenter is trying to take this form:

```kotlin
fun present(/* input streams (observables) */): ViewModel {   
  // ... 
}
```

A function, and a function with a very simple meaning: it transforms a bunch of observables into a bunch of observables.

As input it takes a bunch of observables with user interaction events. A click on a button is an interaction event. Another example is an observable that emits a string each time user types something in an input field.

```kotlin
fun present(
  updateButtonClicks: Observable<Unit>,
  passwordEditTextChanges: Observable<String>
): ViewModel {   
  // ... 
}
```

An output of this function is an instance of `ViewModel` object, which is just a container for a bunch of observables with view states. View state is some property of a view. View visibility, margin or button text are common examples:

```kotlin
data class ViewModel(   
  val progressViewIsVisible: Observable<Boolean>,
  val updateButtonText: Observable<String>
 )
```

[Image of a screen with observables and corresponding views]

To render, we just subscribe to each of these observables and map their values to corresponding view properties:

```kotlin
viewModel.progressViewIsVisible.subscribe {
  progressView.visible = it
}

viewModel.updateButtonText.subscribe {
  updateButton.setText(it)
}
```

Roughly speaking, `present()` is a function that transforms clicks into the screen content:

[clicks -> present() -> view states]

This is how typical activity looks with this approach:

```kotlin
class MainActivity : Activity() {

  override fun onCreate(savedInstanceState: Bundle?) {
    /* ... */
    val viewModel = present(/* input streams */)
    render(viewModel)
  }

}
```

Yes, it's that simple. Activity's role is to resolve dependancies for the `present()` function and to provide an entry point.

## Implementing present() function

`present()` function is the heart of the activity. It owns all the complexity and all non-trivial presentation logic. How is this function implemented? Let's see that on an example of this activity:

[Image]

It has an "Update" button. Each time we click it, a new list of articles is downloaded from the server and displayed on screen.

How to implement this? As an input, we can expect to have a stream of button clicks and something that can download articles for us (let's call it `ArticlesProvider`):

```kotlin
fun present( 
  updateButtonClicks: Observable<Unit>, 
  articlesProvider: ArticlesProvider
): ViewModel {
  /* ... */
}
```

We can combine these two inputs into an observable that downloads and emits a list of articles every time update button is clicked:

```kotlin
val articles = updateButtonClicks
  .flatMap { articlesProvider.getArticles() }    
```

Let's suppose activity knows how to "render" these articles (by passing them to a proper `RecyclerView` adapter for example). Then we can consider this observable a view state and final implementation of the `present()` function will look like this:

```kotlin
fun present( 
  updateButtonClicks: Observable<Unit>, 
  articlesProvider: ArticlesProvider
): ViewModel { 
  val articles = updateButtonClicks
    .flatMap { articlesProvider.getArticles() }    

  return ViewModel( 
    articles = articles 
  )
}
```

It's funny how it resembles ordinary presenter, but let's look into the `articles` observable again:

```kotlin
val articles = updateButtonClicks
  .flatMap { articlesProvider.getArticles() }    
```

This expression defines a rule how to compose `articles` view state. To define another view state, just create a new rule and place it, say, bellow the previous one:

```kotlin
fun present( 
  updateButtonClicks: Observable<Unit>, 
  articlesProvider: ArticlesProvider
): ViewModel { 
  val articles = updateButtonClicks
    .flatMap { articlesProvider.getArticles() }    
    .publish().autoConnect() 

  // This is the new view state.
  // It controls visibility of an “empty state” view
  // which is visible when there is no articles to show
  val emptyViewVisibility = just(true)
    .concatWith(articles.map { it.isEmpty() })

  return ViewModel( 
    articles = articles 
    emptyViewVisibility = emptyViewVisibility 
  )
}
```

And this is how the work process looks like. We identify view states we need to implement, and then we just write a rule for each of these view states. At the end, `present()` function is just a list of view state definitions. It may contain other stuff, of course, like definitions of observables which are used in construction of several view states, but mostly `present()` function is just a list of view states.

It may sound unreal that presentation layer can have such a simple form, but my experience with a real life application with live, changing requirements says that it's pretty real indeed. Your presentation layer is really just a list of view state definitions at the end. It feels like the reason why traditional presenters are so complex is just because we did it wrong all this time. Won't be the first time in the history of software development something like this happens.

It's pretty important to keep your software solution as simple as possible. My general feeling is that with a traditional presenter complexity of your solution increases as a square of complexity of the requirements. Each added requirement tends to affect several pieces of code, and so, the more code you already have, the more is the complexity increase. With the Rx approach it feels like updates are usually much more isolated and complexity of the code is more like of linear dependency on complexity of the requirements. This means that the bigger and more complex your activity is, the greater are the advantages of implementing your presenter with Rx. With simplest activities it feels like complexity of both solutions is just the same.

## Why complexity matters

It's not hard to illustrate what this decrease of complexity gives to you as a developer. Imagine you came to your code after a while. Probably it's time to change how one of the view states works or fix a bug in one of them. To change something, you need to understand it first. Now, you'll probably click on a variable or a function responsible for this view state and browse through all the huge presenter to understand how the pieces are connected. You build a mental model in your head. The problem is, this mental model is pretty unstable. If a colleague comes to your desk and asks something, the model is broken and you'll have to build it again. With Rx presenter it's pretty cheap to rebuild the model, all necessary parts are there, in the single place: in the place where view model observable is defined.

Now, imagine how simpler it is to modify this kind of code, how you can see immediately what you changes do and what they not. You can be sure that you are not introducing some weird bug by manipulating some shared state in an unexpected way. Just because all state mutations are defined in a single place, in the place where corresponding observable is defined. You can grasp everything that happens with a state with a single look.

## The true form of the presenter

In the end I want to share another exciting thing about this approach. This insight comes from André Staltz's talks and MVI documentation from cycle.js site. Let's look again at our activity:

```kotlin
class MainActivity : Activity() {

  override fun onCreate(savedInstanceState: Bundle?) {
    /* ... */
    val viewModel = present(/* input streams */)
    render(viewModel)
  }

}
```

`onCreate()` function serves a role of a main entry point. It's like a `main()`, but for an activity. Having this in mind, we may notice that the code above resembles this:

```kotlin
fun main() {
  render(preset(userInput()))
}
```

What does it mean? We just took our super complex activity, consisting of a view, presenter, asynchronous events of all kinds, and turned it into a composition of three functions. Each of these functions have a deadly simple meaning. Realizing that was a cathartic experience for me, like experiencing some beautiful formula or mathematic law for a first time. Our program suddenly became so simple and easy to think about. May be this is the natural way of how UI programming should be done?

And look at the presenter. It was an abomination with hard to grasp role and a knot of states inside. Now it's a transform function, simple and elegant like a rock garden. It feels like presenter's true form was hidden all these years in a pile of OOP boilerplate and Rx with FRP just helped to reveal it.

I'm pretty convinced now that FRP is the natural way to write UI applications. In my experience it excels traditional imperative approach in all aspects. It feels like a programming paradigm of the future.

## Some nuances

## Signals?

Not everything produced by OOP presenter is a view state. How would you start another activity with your functional presenter?

## Testing?

## Composition?

## Relation to MVI?
